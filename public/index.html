<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <title>Bot de Trading Multi-Ativos - v3.2</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1,
        h2 {
            color: #333;
            text-align: center;
        }

        .status {
            background: #e8f5e8;
            border: 1px solid #4caf50;
            padding: 10px;
            border-radius: 5px;
            margin: 20px 0;
        }

        .test-section {
            background: #f0f8ff;
            border: 1px solid #2196f3;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }

        .warning {
            background: #fff3e0;
            border: 1px solid #ff9800;
            color: #e65100;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            font-weight: bold;
        }

        button {
            background: #4caf50;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }

        button:hover {
            background: #45a049;
        }

        .test-btn {
            background: #2196f3;
        }

        .test-btn:hover {
            background: #1976d2;
        }

        #log {
            background: #f9f9f9;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 5px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }

        select,
        input[type="number"] {
            padding: 8px;
            margin: 10px 5px;
            border-radius: 5px;
        }

        label {
            margin-right: 10px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>üìà Bot de Trading Multi-Ativos v3.2</h1>
        <h2>Monitoramento de ETH, DOGE e Picos (4H)</h2>
        <div class="warning">
            ‚ö†Ô∏è ATEN√á√ÉO: Nunca exponha seu Token de Bot do Telegram em c√≥digo que roda no navegador. Ele pode ser
            roubado! Use este script em um servidor seguro.
        </div>
        <div class="status">
            <strong>Status:</strong> <span id="status">Inicializando...</span>
        </div>
        <div class="test-section">
            <h3>üß™ Teste de Conex√£o</h3>
            <p>Teste o envio de mensagens para o Telegram:</p>
            <button class="test-btn" onclick="sendTestMessage()">üì± Enviar Teste</button>
        </div>
        <div>
            <h3>üìä Controles</h3>
            <label for="entryValue">Valor de Entrada (USD):</label>
            <input type="number" id="entryValue" min="1" placeholder="Ex.: 200" />
            <select id="assetSelect" onchange="updateAsset()">
                <option value="DOGEUSDT">DOGEUSDT</option>
                <option value="ETHUSDT">ETHUSDT</option>
                <option value="TRENDING">Ativos com Picos</option>
            </select>
            <button onclick="startBot()">‚ñ∂Ô∏è Iniciar Bot</button>
            <button onclick="stopBot()">‚èπÔ∏è Parar Bot</button>
            <button onclick="checkNow()">üîç Verificar Agora</button>
        </div>
        <div>
            <h3>üìù Log de Atividades</h3>
            <div id="log"></div>
        </div>
    </div>
    <script>
        // Aviso de Seguran√ßa: Token exposto no c√≥digo do lado do cliente
        const telegramBotToken = "7638628732:AAHFNGTcoikDyJctbMXD1MbQlwRsR70Npn8";
        const telegramChatId = "@DogeEntradas";

        // Configura√ß√µes de Trade
        const ENTRY_PROFILE = {
            leverage: "10x",
            positionSize: "10%",
            longTP: "+4%",
            longSL: "-2%",
            shortTP: "-4%",
            shortSL: "+2%"
        };
        const DEFAULT_ENTRY_VALUE = 100; // Valor padr√£o se o campo estiver vazio
        const ADX_MINIMO_TENDENCIA = 25;
        const PEAK_THRESHOLD = 10; // Varia√ß√£o m√≠nima em 24h ap√≥s pico recente
        const checkInterval = 10 * 60 * 1000; // 10 minutos
        const apiKlineUrl = "https://api.bybit.com/v5/market/kline";
        const apiTickersUrl = "https://api.bybit.com/v5/market/tickers?category=linear";

        let botInterval = null;
        let isRunning = false;
        let lastSignalTimestamps = {};
        let trendingAssets = [];

        function log(message) {
            const logElement = document.getElementById('log');
            const timestamp = new Date().toLocaleString('pt-BR');
            logElement.innerHTML += `[${timestamp}] ${message}<br>`;
            logElement.scrollTop = logElement.scrollHeight;
        }

        function updateStatus(status) {
            document.getElementById('status').textContent = status;
        }

        async function sendTestMessage() {
            try {
                log('Enviando mensagem de teste...');
                const now = new Date().toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo' });
                const testMsg = `‚úÖ Teste do Bot de Trading v3.2\nData: ${now}`;
                await sendTelegramMessage(testMsg);
                log('‚úÖ Mensagem de teste enviada!');
            } catch (error) {
                log(`‚ùå Erro no teste: ${error.message}`);
            }
        }

        async function sendTelegramMessage(msg) {
            const response = await fetch(`https://api.telegram.org/bot${telegramBotToken}/sendMessage`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ chat_id: telegramChatId, text: msg })
            });
            if (!response.ok) throw new Error(`Erro Telegram: ${await response.text()}`);
            return response.json();
        }

        async function fetchKlineData(symbol) {
            const params = new URLSearchParams({ category: "linear", symbol, interval: "240", limit: "200" });
            try {
                const response = await fetch(`${apiKlineUrl}?${params}`);
                if (!response.ok) throw new Error(`Erro API Bybit: ${response.statusText}`);
                const json = await response.json();
                if (json.retCode !== 0) throw new Error(`Erro API: ${json.retMsg}`);
                return json.result.list.map(item => ({
                    time: Number(item[0]),
                    open: Number(item[1]),
                    high: Number(item[2]),
                    low: Number(item[3]),
                    close: Number(item[4]),
                    volume: Number(item[5])
                })).reverse();
            } catch (error) {
                log(`‚ùå Erro ao buscar dados de ${symbol}: ${error.message}`);
                return [];
            }
        }

        async function fetchTrendingAssets() {
            try {
                const response = await fetch(apiTickersUrl);
                const json = await response.json();
                if (json.retCode !== 0) throw new Error(`Erro API: ${json.retMsg}`);
                trendingAssets = [];
                for (const ticker of json.result.list) {
                    if (!ticker.symbol.endsWith("USDT")) continue;
                    const candles = await fetchKlineData(ticker.symbol);
                    if (candles.length < 6) continue;
                    const recentCandles = candles.slice(-6); // √öltimos 24h (6 candles de 4h)
                    const olderPrice = candles[candles.length - 12]?.close || candles[0].close; // Aproximadamente 48h atr√°s
                    const currentPrice = candles[0].close;
                    const totalChange = ((currentPrice - olderPrice) / olderPrice) * 100;
                    if (totalChange < PEAK_THRESHOLD) continue;
                    const recentChange = recentCandles.reduce((sum, c) => sum + ((c.close - c.open) / c.open) * 100, 0);
                    if (recentChange > totalChange * 0.7) { // Pico recente contribui com >70% da varia√ß√£o
                        trendingAssets.push(ticker.symbol);
                    }
                }
                log(`üìà Ativos com picos: ${trendingAssets.join(', ') || 'Nenhum'}`);
            } catch (error) {
                log(`‚ùå Erro ao buscar ativos com picos: ${error.message}`);
            }
        }

        // Indicadores T√©cnicos
        function sma(data, period) {
            let sums = [];
            for (let i = 0; i <= data.length - period; i++) {
                let sum = 0;
                for (let j = 0; j < period; j++) sum += data[i + j];
                sums.push(sum / period);
            }
            return sums;
        }

        function ema(data, period) {
            const k = 2 / (period + 1);
            let emaData = [data[0]];
            for (let i = 1; i < data.length; i++) {
                emaData.push(data[i] * k + emaData[i - 1] * (1 - k));
            }
            return emaData;
        }

        function rsi(data, period = 14) {
            let gains = [], losses = [];
            for (let i = 1; i < data.length; i++) {
                const diff = data[i] - data[i - 1];
                gains.push(diff > 0 ? diff : 0);
                losses.push(diff < 0 ? -diff : 0);
            }
            let avgGain = gains.slice(0, period).reduce((a, b) => a + b) / period;
            let avgLoss = losses.slice(0, period).reduce((a, b) => a + b) / period;
            let rsiValues = [100 - (100 / (1 + (avgGain / avgLoss)))];
            for (let i = period; i < gains.length; i++) {
                avgGain = (avgGain * (period - 1) + gains[i]) / period;
                avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
                rsiValues.push(avgLoss === 0 ? 100 : 100 - (100 / (1 + (avgGain / avgLoss))));
            }
            return rsiValues;
        }

        function stochastic(highs, lows, closes, kPeriod, kSlowing, dPeriod) {
            let ll = [], hh = [];
            for (let i = kPeriod - 1; i < closes.length; i++) {
                ll.push(Math.min(...lows.slice(i - kPeriod + 1, i + 1)));
                hh.push(Math.max(...highs.slice(i - kPeriod + 1, i + 1)));
            }
            let k = [];
            for (let i = 0; i < ll.length; i++) {
                k.push(100 * (closes[i + kPeriod - 1] - ll[i]) / (hh[i] - ll[i] || 1));
            }
            let smoothedK = sma(k, kSlowing);
            let d = sma(smoothedK, dPeriod);
            return { k: smoothedK, d: d };
        }

        function adx(highs, lows, closes, period) {
            let trs = [], plusDMs = [], minusDMs = [];
            for (let i = 1; i < highs.length; i++) {
                let tr1 = highs[i] - lows[i];
                let tr2 = Math.abs(highs[i] - closes[i - 1]);
                let tr3 = Math.abs(lows[i] - closes[i - 1]);
                trs.push(Math.max(tr1, tr2, tr3));
                let upMove = highs[i] - highs[i - 1];
                let downMove = lows[i - 1] - lows[i];
                plusDMs.push((upMove > downMove && upMove > 0) ? upMove : 0);
                minusDMs.push((downMove > upMove && downMove > 0) ? downMove : 0);
            }
            const wildersSmooth = (data) => {
                let smoothed = [data.slice(0, period).reduce((a, b) => a + b)];
                for (let i = period; i < data.length; i++) {
                    smoothed.push(smoothed.at(-1) - (smoothed.at(-1) / period) + data[i]);
                }
                return smoothed;
            };
            let smoothedTR = wildersSmooth(trs);
            let smoothedPlusDM = wildersSmooth(plusDMs);
            let smoothedMinusDM = wildersSmooth(minusDMs);
            let plusDIs = [], minusDIs = [], dxs = [];
            for (let i = 0; i < smoothedTR.length; i++) {
                plusDIs.push(100 * (smoothedPlusDM[i] / smoothedTR[i]));
                minusDIs.push(100 * (smoothedMinusDM[i] / smoothedTR[i]));
            }
            for (let i = 0; i < plusDIs.length; i++) {
                dxs.push(100 * Math.abs(plusDIs[i] - minusDIs[i]) / (plusDIs[i] + minusDIs[i]));
            }
            let adxValues = wildersSmooth(dxs.slice(period - 1));
            return { adx: adxValues, plusDI: plusDIs, minusDI: minusDIs };
        }

        function calculateEstimatedProfit(isShort) {
            const entryValueInput = document.getElementById('entryValue').value;
            const entryValue = (entryValueInput && Number(entryValueInput) > 0) ? Number(entryValueInput) : DEFAULT_ENTRY_VALUE;
            const leverage = 10; // 10x
            const tpPercent = isShort ? -4 : 4; // TP em %
            const profit = (entryValue * leverage * Math.abs(tpPercent)) / 100;
            return { profit: profit.toFixed(2), entryValue };
        }

        async function checkSignal(symbol) {
            if (!isRunning) return;
            try {
                log(`üîç Verificando ${symbol}...`);
                const candles = await fetchKlineData(symbol);
                if (candles.length < 150) {
                    log(`‚ùå Dados insuficientes para ${symbol}.`);
                    return;
                }
                const currentCandleTimestamp = candles.at(-1).time;
                if (lastSignalTimestamps[symbol] === currentCandleTimestamp) {
                    log(`‚è≥ Sinal j√° enviado para ${symbol} neste candle.`);
                    return;
                }
                const closes = candles.map(c => c.close);
                const highs = candles.map(c => c.high);
                const lows = candles.map(c => c.low);
                const ema17 = ema(closes, 17);
                const ema50 = ema(closes, 50);
                const ema72 = ema(closes, 72);
                const rsi14 = rsi(closes, 14);
                const stoch = stochastic(highs, lows, closes, 14, 5, 5);
                const adxResult = adx(highs, lows, closes, 14);
                const currentPrice = closes.at(-1);
                const lastEma17 = ema17.at(-1);
                const lastEma50 = ema50.at(-1);
                const lastEma72 = ema72.at(-1);
                const lastRsi = rsi14.at(-1);
                const lastStochK = stoch.k.at(-1);
                const lastAdx = adxResult.adx.at(-1);
                log(`üìä ${symbol} | Pre√ßo: ${currentPrice.toFixed(5)} | RSI: ${lastRsi.toFixed(2)} | ADX: ${lastAdx.toFixed(2)}`);
                const isLong = lastEma17 > lastEma50 && lastEma50 > lastEma72 && lastRsi > 50 && lastAdx > ADX_MINIMO_TENDENCIA && lastStochK < 80;
                const isShort = lastEma17 < lastEma50 && lastEma50 < lastEma72 && lastRsi < 50 && lastAdx > ADX_MINIMO_TENDENCIA && lastStochK > 20;
                if (isLong || isShort) {
                    const op = isShort ? "SHORT (VENDA)" : "LONG (COMPRA)";
                    const { profit, entryValue } = calculateEstimatedProfit(isShort);
                    const msg = `
üì¢ ENTRADA CONFIRMADA - ${symbol} (4H) üì¢
An√°lise: ${new Date().toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo' })}
üîπ Opera√ß√£o: ${op}
üîπ Ativo: ${symbol}
üîπ Entrada: ~${currentPrice.toFixed(5)}
üîπ Valor de Entrada: $${entryValue.toFixed(2)}
üîπ Alavancagem: ${ENTRY_PROFILE.leverage}
üîπ Gerenciamento: ${ENTRY_PROFILE.positionSize}
üéØ Take Profit: ${isShort ? ENTRY_PROFILE.shortTP : ENTRY_PROFILE.longTP}
üõ°Ô∏è Stop Loss: ${isShort ? ENTRY_PROFILE.shortSL : ENTRY_PROFILE.longSL}
üí∞ Ganho Estimado: $${profit}
#TradeSignal #Bybit
                    `;
                    await sendTelegramMessage(msg);
                    log(`üöÄ Sinal ${op} enviado para ${symbol}!`);
                    lastSignalTimestamps[symbol] = currentCandleTimestamp;
                } else {
                    log(`‚è≥ Nenhuma entrada clara para ${symbol}.`);
                }
            } catch (error) {
                log(`‚ùå Erro ao verificar ${symbol}: ${error.message}`);
            }
        }

        async function checkAllSignals() {
            const selectedAsset = document.getElementById('assetSelect').value;
            let assets = ['DOGEUSDT', 'ETHUSDT'];
            if (selectedAsset === 'TRENDING') {
                await fetchTrendingAssets();
                assets = trendingAssets;
            } else if (selectedAsset !== 'ALL') {
                assets = [selectedAsset];
            }
            for (const asset of assets) {
                await checkSignal(asset);
            }
        }

        function startBot() {
            if (isRunning) {
                log('‚ö†Ô∏è Bot j√° est√° rodando!');
                return;
            }
            isRunning = true;
            updateStatus('üü¢ Rodando - Monitoramento ativo');
            log('‚ñ∂Ô∏è Bot iniciado! Verificando a cada 10 minutos.');
            checkAllSignals();
            botInterval = setInterval(checkAllSignals, checkInterval);
        }

        function stopBot() {
            if (!isRunning) {
                log('‚ö†Ô∏è Bot j√° est√° parado!');
                return;
            }
            isRunning = false;
            clearInterval(botInterval);
            botInterval = null;
            lastSignalTimestamps = {};
            updateStatus('üî¥ Parado');
            log('‚èπÔ∏è Bot parado! Mem√≥ria de sinais limpa.');
        }

        function checkNow() {
            if (!isRunning) {
                log('‚ö†Ô∏è Inicie o bot primeiro!');
                return;
            }
            log('For√ßando verifica√ß√£o imediata...');
            checkAllSignals();
        }

        function updateAsset() {
            log(`Ativo selecionado: ${document.getElementById('assetSelect').value}`);
        }

        document.addEventListener('DOMContentLoaded', () => {
            alert("AVISO DE SEGURAN√áA: Token do Telegram exposto. Use apenas em ambiente seguro!");
            updateStatus('üü° Pronto para iniciar');
            log('ü§ñ Bot v3.2 carregado e pronto!');
        });
    </script>
</body>

</html>